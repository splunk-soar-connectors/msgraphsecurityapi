<!--File: readme.html
Copyright (c) 2022 Splunk Inc.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
either express or implied. See the License for the specific language governing permissions
and limitations under the License.
-->

<p>
<h2>Configure and set up permissions of the app created on the Microsoft Azure portal</h2>
<p>
  <ul>
    <h4>Create the app</h4>
    <ol>
    <li>Navigate to <a href="https://portal.azure.com" target="_blank">https://portal.azure.com</a>.</li>
    <li>Select the 'App registrations'.</li>
    <li>Select the 'New Registration' option at the top of the page.</li>
    <li>In the registration form, choose a name for your application and then click 'Register'.</li>
    </ol>
    <h4>Add permissions</h4>
    <ol start=7>
    <li>Select the 'API Permissions' menu from the left-side panel.</li>
    <li>Click on 'Add a permission'.</li>
    <li>Search for 'Microsoft Graph' keyword in the search box and click on the displayed option for it.</li>
    <li>Provide the following Delegated and Application permissions to the app.
      <ul>
        <li>User.Read.All (https://graph.microsoft.com/User.Read.All)</li>
        <ul>
          <li>For non-admin access, use User.Read (Delegated permission) instead (https://graph.microsoft.com/User.Read)
          </li>
        </ul>
        <li>
          SecurityEvents.Read.All (https://graph.microsoft.com/SecurityEvents.Read.All)
        </li>
        <li>
          SecurityEvents.ReadWrite.All (https://graph.microsoft.com/SecurityEvents.ReadWrite.All)
        </li>
      </ul>
    </li>
    <li>select <b>Grant admin consent for &lt;your_organization_name_as_on_azure_portal&gt;</b> at the bottom of the screen.</li>
    </ol>
    <h4>Create a client secret</h4>
    <ol start=17>
    <li>Select the 'Certificates &amp; secrets' menu from the left-side panel.</li>
    <li>Select 'New client secret' button to open a pop-up window.</li>
    <li>Provide the description, select an appropriate option for deciding the client secret expiration time, and click on the 'Add' button.</li>
    <li>Click 'Copy to clipboard' to copy the generated secret value and paste it in a safe place. You will need it to configure the asset and will not be able to retrieve it later.</li>
    </ol>
    <h4>Copy your application id and tenant id</h4>
    <ol start=21>
    <li>Select the 'Overview' menu from the left-side panel.</li>
    <li>Copy the <b>Application (client) ID</b> and <b>Directory (tenant) ID</b>. You will need these to configure the SOAR asset.
    </ol>
  </ul>
</p>

After making these changes, click <b>Add permissions</b>, then select <b>Grant admin consent for &lt;your_organization_name_as_on_azure_portal&gt;</b> at the bottom of the screen.
<h2>Splunk SOAR Graph Asset</h2>
When creating an asset for the <b>MS Graph for Security API</b> app, place <b>Application ID</b> of the app created during the app registration on the Azure Portal in the <b>Application ID</b> field and place the client secret generated during the app registration process in the <b>Application Secret</b> field. Then, after filling out the <b>Tenant</b> field, click <b>SAVE</b>. Both the Application/Client ID and the Tenant ID can be found in the <b>Overview</b> tab on your app's Azure page.
<br><br>
After saving, a new field will appear in the <b>Asset Settings</b> tab. Take the URL found in the <b>POST incoming for MS Graph for Security API to this location</b> field and place it in the <b>Redirect URLs</b> field mentioned in the previous step. To this URL, add <b>/result</b>. After doing so the URL should look something like:
<br><br>
<p>
  https://10.1.66.167/rest/handler/microsoftgraphsecurityapi_781c8000-129d-4134-bcfd-41b490c288fe/mgsapi/result
  </p>
<br>
Once again, click save at the bottom of the screen.
<br>
<br><br>
Additionally, updating the Base URL in the Company Settings is also required. Navigate to <b>Administration > Company Settings > Info</b> to configure the <b>Base URL For Splunk SOAR</b>. Then, select <b>Save Changes</b>.
<br><br>

<h2>User Permissions</h2>
To complete the authorization process, this app needs permission to view assets, which is not granted by default. First, navigate to <b>Asset Settings > Advanced</b>, to check which user is listed under <b>Select a user on behalf of which automated actions can be executed</b>. By default, the user will be <b>automation</b>, but this user can be changed by clicking <b>EDIT</b> at the bottom of the window. To give this user permission to view assets, follow these steps:
<ul>
    <li>In the main drop-down menu, select <b>Administration</b>, then select the <b>User Management</b>, and under that tab, select <b>Roles & Permissions</b>. Finally, click <b>+ ROLE</b>.</li>
    <li>In the <b>Add Role</b> wizard, give the role a name (e.g <b>Asset Viewer</b>), and provide a description. Subsequently, under the <b>Users tab</b>, click <b>ADD USERS</b> to add the user assigned to the asset viewed earlier. Then click the <b>Permissions</b> tab.</li>
    <li>In the permission tab, under <b>Basic Permissions</b>, give the role the <b>View Assets</b> privilege. Then click <b>SAVE</b>.</li>
</ul>

<h3>Method to run Test Connectivity</h3><ul>
<li>After setting up the asset and user, click the <b>TEST CONNECTIVITY</b> button. A window should pop up and display a
URL. </li>
<li>Navigate to this URL in a separate browser tab. This new tab will redirect to a Microsoft login page.</li>
<li>Log in to a Microsoft account with administrator privileges to the desired mailboxes. After logging in, review the requested
  permissions listed, then click <b>Accept</b>. Finally, close that tab.</li>
<li>test connectivity window should show success.</li>
</ul>
The app should now be ready to be used.
<br />

<h2>State file permissions</h2>
  <p>
    Please check the permissions for the state file as mentioned below.
    <h4>State file path</h4>
    <ul>
      <li>For Non-NRI instance: /opt/phantom/local_data/app_states/&lt;appid&gt;/&lt;asset_id&gt;_state.json</li>
      <li>For NRI instance: /&lt;PHANTOM_HOME_DIRECTORY&gt;/local_data/app_states/&lt;appid&gt;/&lt;asset_id&gt;_state.json</li>
    </ul>
    <h4>State file permissions</h4>
    <ul>
      <li>File rights: rw-rw-r-- (664) (The Splunk SOAR user should have read and write access for the state file)</li>
      <li>File owner: Appropriate Splunk SOAR user</li>
    </ul>
  </p>
  <h2>Explanation of Close alert action</h2>
  <li>
    <b>Configuration:</b><br>
    <ul>
      <li>Status - It allows a user to define what status "Closed" means.  Default is "resolved" </li>
    </ul>
    <li>
      This action will update the alert's 'closedDateTime' parameter to the current system datetime
    </li>
  </li>


  <h2>Explanation of On-Poll Workflow</h2>
    <ul>

        <li>Common points for both manual and scheduled interval polling
            <ul>
              <li>
                <b>Configuration:</b><br>
                <ul>
                  <li>start_time_for_poll - Alert whose 'lastModifiedDateTime' greater than this time will be fetched </li>
                  <li>max_artifacts - Maximum allowed Artifacts in a single container (Default: 500)</li>
                </ul>
              </li>
               <li>
                Apart from artifact_count other default parameters of the On Poll action are ignored in the app. i.e. start_time, end_time, container_id, container_count
                </li>
                <li>
                  The action uses alert's 'lastModifiedDateTime' property as a checkpoint
                  </li>
                  <li>
                    On every polling cycle, the action will fetch a single alert from each available provider. After this, we will have all the available providers' list. Then using filter parameter it will fetch alerts for each provider individually in 'ascending' order.
                    To ingest the data; every time a new container will be created using this naming convention - 	&#60;Provider name&#62; &#60;Container creation datetime&#62; and all the alerts of that particular provider will be saved as artifacts.
                  </li>

            </ul>
        </li>

        <li>Manual Polling
            <ul>
                <li>
                  <b>Configuration:</b><br>
                  <ul>
                    <li>artifact_count - Limit for number of alerts to ingest for each individual provider</li>
                  </ul>
                </li>
                <li>
                After getting list of providers, action will fetch all the alerts whose 'lastModifiedDateTime' is greater than 'start_time_for_poll'.
                then the containers will be created for an individual provider. 'max_artifacts' parameter will be considered as a limit to ingested artifacts in one container.
                For example if value of 'max_artifacts' is 20, there are total 3 providers and 'artifact_count' is 100. The action will fetch 100 alerts for each provider and create 15 containers (5 containers for each provider) so, all the containers will have 20 alerts (artifacts) each.
                </li>

            </ul>
        </li>

        <li>Scheduled | Interval Polling
            <ul>
              <li>
                <b>Configuration:</b><br>
                <ul>
                  <li>first_run_max_alerts - Maximum Alerts for each provider in scheduled polling first time (Default: 1000)</li>
                </ul>
              </li>
                <li>
                  After getting list of providers, action will fetch all the alerts whose 'lastModifiedDateTime' is greater than 'start_time_for_poll'.
                  then the containers will be created for individual provider. 'first_run_max_alerts' parameter will be considered as limit to fetch number of alerts for first call.
                </li>
                <li>
                  After ingestion, it will save 'lastModifiedDateTime' of each provider's last alert (artifact) for subsequent calls.
                </li>
                <li>
                  Now after first call it will fetch alerts whose 'lastModifiedDateTime' is greater than saved 'lastModifiedDateTime' of last ingested alert.
                </li>
                <li>
                  If the action found a new provider after the first call action will fetch alerts whose 'lastModifiedDateTime' is greater than 'start_time_for_poll'. i.e. If there is no saved time found then 'start_time_for_poll' will be considered as starting point.
                </li>
                <li>
                For example,  If the value of 'max_artifacts' is 20 and there are total 3 providers. For all runs, the action will create different containers for 20 alerts.
                so if there are 200 alerts fetched in one of the runs for one provider, action will create 10 containers with 20 alerts each for that provider. here we have 3 providers so total 30 containers will be created in that particular run
                </li>
            </ul>
        </li>
   </ul>
